# Notification System Implementation

## Overview
The notification system is now fully implemented as **system-generated notifications** that are automatically created when specific events occur. Notifications are **never created via frontend** - they are generated by the backend service layer.

## Implementation Details

### 1. Notification Model (`Notification.java`)
- ✅ Added `read` boolean field (defaults to `false`)
- ✅ Has `message`, `channel` (enum), `sentAt` timestamp
- ✅ Belongs to one `User` (recipient) - required
- ✅ Optionally references an `IssueReport` - nullable
- ✅ All fields properly mapped to database columns

### 2. Notification Service (`NotificationService.java`)
- ✅ `createNotification()` - Creates system-generated notifications
- ✅ `markAsRead()` - Marks a notification as read
- ✅ `getByRecipient()` - Gets all notifications for a user
- ✅ `getByIssue()` - Gets all notifications for an issue
- ✅ `getAll()` - Gets paginated notifications with role-based filtering

### 3. Automatic Notification Triggers

#### When Issue is Created:
- **Trigger**: `IssueService.createFromDTO()` or `IssueService.create()`
- **Recipients**: All ADMIN users
- **Message**: `"New issue reported: '{title}' by {reporter} in {location}"`
- **Implementation**: `notifyAdminsAboutNewIssue()` method

#### When Issue Status Changes:
- **Trigger**: `IssueService.updateStatus()`
- **Recipients**: The reporting resident (issue.reportedBy)
- **Message**: 
  - `"Your issue '{title}' is now being processed"` (IN_PROGRESS)
  - `"Your issue '{title}' has been resolved"` (RESOLVED)
  - Custom message for other status changes
- **Implementation**: `notifyResidentAboutStatusChange()` method

### 4. Notification Controller (`NotificationController.java`)
- ✅ `GET /api/notifications` - Get all notifications (paginated, role-based)
- ✅ `GET /api/notifications/{id}` - Get notification by ID
- ✅ `GET /api/notifications/user/{userId}` - Get notifications for a user
- ✅ `GET /api/notifications/issue/{issueId}` - Get notifications for an issue
- ✅ `PUT /api/notifications/{id}/read` - Mark notification as read
- ✅ `PUT /api/notifications/read-all` - Mark all user's notifications as read
- ✅ `GET /api/notifications/search?q=...` - Search notifications
- ❌ **Removed**: `POST /api/notifications/send/{userId}/{issueId}` - Notifications are system-generated only

### 5. Role-Based Access Control
- **ADMIN users**: See all notifications
- **RESIDENT users**: See only their own notifications
- All endpoints respect role-based filtering

## Database Schema
The `notifications` table should have:
- `id` (UUID, primary key)
- `message` (TEXT)
- `channel` (VARCHAR - enum: EMAIL, SMS, SYSTEM)
- `sent_at` (TIMESTAMP)
- `delivered` (BOOLEAN)
- `read` (BOOLEAN, default false) - **NEW**
- `recipient_id` (UUID, foreign key to users, NOT NULL)
- `issue_id` (UUID, foreign key to issues, nullable)

## Usage Examples

### Creating a New Issue (Automatic Notification)
```java
// When a resident creates an issue via IssueController
IssueReport issue = issueService.createFromDTO(dto);
// → Automatically notifies all ADMIN users
```

### Updating Issue Status (Automatic Notification)
```java
// When admin updates issue status
issueService.updateStatus(issueId, Status.IN_PROGRESS);
// → Automatically notifies the reporting resident
```

### Fetching Notifications
```http
GET /api/notifications?page=0&size=10
Authorization: Bearer {token}
```

### Marking as Read
```http
PUT /api/notifications/{id}/read
Authorization: Bearer {token}
```

## Error Handling
- Notification creation failures are logged but **do not fail** the main operation (issue creation/status update)
- This ensures that notification issues don't break core functionality

## Future Enhancements
- Add notification types/categories
- Add notification preferences per user
- Add email/SMS channel support (currently only SYSTEM)
- Add notification batching/grouping
- Add notification expiration/cleanup

